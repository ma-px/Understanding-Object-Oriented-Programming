# Preface (rough draft)

This book is about object-oriented programming. I’ve called it Understanding Object-Oriented Programming for a reason; the understanding part really matters. Many programmers pick up just enough OOP to get their work done and then stop there. They don’t take the time to fully explore its core ideas, but that has a cost, without real understanding, programming often becomes harder in the long run. Limited knowledge leads to messy, rigid code that’s difficult to maintain and frustrating to extend.

My goal is to teach OOP from the ground up. I want you to feel as though you are discovering OOP yourself, step by step. I believe OOP should be taught this way, because true understanding comes when you see not just how it works but also why. With this foundation, you’ll be able to make better decisions about which techniques to apply in different situations. It also makes advanced topics, like design patterns, far easier to grasp. Even if you are already a professional programmer, you’ll find parts of this book that challenge your assumptions and deepen your understanding.

A second goal of this book is to clear away the misinformation that surrounds OOP. Over the years, important concepts have often been explained poorly or even taught incorrectly, which has made learning OOP more difficult than it needs to be. I aim to provide you with a clear, practical path to understanding OOP the way it was meant to be understood.

This book is not intended for complete beginners to programming. I assume you already have at least 6 to 9 months of experience with procedural programming. That foundation will make it much easier for you to connect new OOP ideas with what you already know.

You’ll also notice that I don’t stick to any single programming language. Instead, I use pseudocode that resembles C-style languages. Think of it as a “teaching language” I wish existed. No one language demonstrates all the important OOP concepts equally well; some excel at certain features while others completely ignore them. Rather than limiting examples to a single language, I’ve borrowed the best ideas from many OOP languages and combined them into examples that highlight the concepts, not the syntax.

if you’d like to experiment with runnable code, you can even take the pseudocode and use your favorite large language model to translate it into the closest version in the OOP language of your choice.